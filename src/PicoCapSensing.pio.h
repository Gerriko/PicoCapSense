// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -------- //
// capsensing //
// -------- //

#define capsensing_wrap_target 0
#define capsensing_wrap 29

static const uint16_t capsensing_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block
    0xf080, //  1: set    pindirs, 0      side 0
    0xe081, //  2: set    pindirs, 1
    0xe000, //  3: set    pins, 0
    0xe033, //  4: set    x, 19
    0xa0c1, //  5: mov    isr, x
    0x4066, //  6: in     null, 6
    0xa026, //  7: mov    x, isr
    0x0048, //  8: jmp    x--, 8
    0xf880, //  9: set    pindirs, 0      side 1
    0x2020, // 10: wait   0 pin, 0
    0xa027, // 11: mov    x, osr
    0x004e, // 12: jmp    x--, 14
    0x001a, // 13: jmp    26
    0x00d0, // 14: jmp    pin, 16
    0x000c, // 15: jmp    12
    0xe001, // 16: set    pins, 1
    0xe081, // 17: set    pindirs, 1
    0xe001, // 18: set    pins, 1
    0xf080, // 19: set    pindirs, 0      side 0
    0x0056, // 20: jmp    x--, 22
    0x001a, // 21: jmp    26
    0x00d4, // 22: jmp    pin, 20
    0xa0c1, // 23: mov    isr, x
    0x8020, // 24: push   block
    0x0000, // 25: jmp    0
    0xe020, // 26: set    x, 0
    0xa0c1, // 27: mov    isr, x
    0x8020, // 28: push   block
    0x0000, // 29: jmp    0
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program capsensing_program = {
    .instructions = capsensing_program_instructions,
    .length = 30,
    .origin = -1,
};

static inline pio_sm_config capsensing_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + capsensing_wrap_target, offset + capsensing_wrap);
    sm_config_set_sideset(&c, 2, true, false);
    return c;
}

// this is a raw helper function for use by the user which sets up the GPIO output, and configures the SM to output on a particular pin
static inline void capsensing_program_init(PIO pio, uint sm, uint offset, uint trig_pin, uint read_pin) {
  gpio_set_pulls(read_pin, false, false);         // make sure internal pull-up / pull-down not enabled

  // Ensure that the state machine is not running before config
  pio_sm_set_enabled(pio, sm, false);
  // Clear all fifos
  pio_sm_clear_fifos(pio, sm);
  pio_sm_restart(pio, sm);

  pio_gpio_init(pio, trig_pin);
  pio_gpio_init(pio, read_pin);

  pio_sm_set_consecutive_pindirs (pio, sm, trig_pin, 1, true);

  pio_sm_config c = capsensing_program_get_default_config(offset);
  // use in config for the read pin to allow direction and state to change
  sm_config_set_in_pins(&c, read_pin);
  // set the 'jmp' pin as the same as in pin as will be used to check pin state (if true checks)
  sm_config_set_jmp_pin(&c, read_pin);
  // use set config for the read pin to allow direction and state to change
  sm_config_set_set_pins(&c, read_pin, 1);
  // use out and sideset config for the trig pin to allow output state to change in parallel with read_pin
  sm_config_set_sideset_pins(&c, trig_pin);
  // Load our configuration, and jump to the start of the program
  pio_sm_init(pio, sm, offset, &c);

}

#endif
